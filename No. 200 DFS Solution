class Solution(object):
    def numIslands(self, grid):
        if not grid:
           return 0
    
        m, n = len(grid), len(grid[0])
        visited = set() #也可以在dfs（r，c）中将访问过的点的值变为‘0’，这样可以不用到集合
    
        def dfs(r, c):
            # If out of bounds or already visited or water, stop
            if (r < 0 or r >= m or 
               c < 0 or c >= n or 
               grid[r][c] == "0" or
               (r, c) in visited):
               return
            visited.add((r, c))
            # Explore neighbors (up, down, left, right)
            dfs(r+1, c)
            dfs(r-1, c)
            dfs(r, c+1)
            dfs(r, c-1) #以上四行利用函数递归，将发现的‘1’周围其他的‘1’叶全部记录到visited中，从而保证每发现第一个1，就可以发现整个岛屿，避免重复访问已发现岛屿上的坐标
    
        num_islands = 0
        for r in range(m):
            for c in range(n):
                if grid[r][c] == "1" and (r, c) not in visited:
                   dfs(r, c)
                   num_islands += 1
        return islands
